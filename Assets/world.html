<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MCTwin // World Explorer</title>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #87CEEB;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        canvas.oncontextmenu = (e) => e.preventDefault();
        const engine = new BABYLON.Engine(canvas, true);
        let shadowGenerator;
        let playerRoot = null;
        let sun, hemi, ground, groundMat; // Exposed for updates

        const createScene = function () {
            const scene = new BABYLON.Scene(engine);

            // Sky
            scene.clearColor = new BABYLON.Color4(0.53, 0.81, 0.92, 1);
            scene.ambientColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            var env = scene.createDefaultEnvironment({
                createSkybox: false,
                createGround: false,
                setupImageProcessing: true,
                environmentTexture: "https://assets.babylonjs.com/environments/studio.env"
            });
            scene.environmentIntensity = 0.8;
            // Fog Removed by User Request
            // scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            // scene.fogDensity = 0.01;
            // scene.fogColor = new BABYLON.Color3(0.53, 0.81, 0.92);

            // Camera (Follow) - Set to -Math.PI/2 to look from the FRONT (Negative Z)
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.2, 100, new BABYLON.Vector3(0, 16, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 2000;
            camera.wheelPrecision = 6.0; // Responsive zoom
            camera.panningSensibility = 100; // Lower is faster/more responsive
            camera.panningMouseButton = 2;    // Explicitly set Right-Click (2)

            // Lighting
            sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -2, -1), scene);
            sun.position = new BABYLON.Vector3(50, 100, 50);
            sun.intensity = 1.0;

            hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.6;

            shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.setDarkness(0.4);

            // Ground
            ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 500, height: 500 }, scene);
            groundMat = new BABYLON.StandardMaterial("gMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.5, 0.2);
            groundMat.specularColor = new BABYLON.Color3(0, 0, 0);

            // Checkerboard
            const chk = new BABYLON.Texture("https://assets.babylonjs.com/textures/checkerboard_base.png", scene);
            chk.uScale = 50;
            chk.vScale = 50;
            groundMat.diffuseTexture = chk;

            ground.material = groundMat;
            ground.receiveShadows = true;

            const meshMap = new Map();

            // INPUT
            const input = { w: false, s: false, a: false, d: false };
            window.addEventListener("keydown", (e) => {
                switch (e.key.toLowerCase()) {
                    case "w": input.w = true; break;
                    case "s": input.s = true; break;
                    case "a": input.a = true; break;
                    case "d": input.d = true; break;
                }
            });
            window.addEventListener("keyup", (e) => {
                switch (e.key.toLowerCase()) {
                    case "w": input.w = false; break;
                    case "s": input.s = false; break;
                    case "a": input.a = false; break;
                    case "d": input.d = false; break;
                }
            });

            window.addEventListener("keydown", (e) => {
                if (e.key.toLowerCase() === "f" && playerRoot) {
                    camera.setTarget(new BABYLON.Vector3(playerRoot.position.x, playerRoot.position.y + 16, playerRoot.position.z));
                }
            });

            // GIZMOS (Manipulation)
            const gizmoManager = new BABYLON.GizmoManager(scene);
            gizmoManager.positionGizmoEnabled = true;
            gizmoManager.usePointerToAttachGizmos = false; // Custom logic

            // Fix for camera fight (Removed detachment to allow panning while selected)
            gizmoManager.onAttachedToMeshObservable.add((mesh) => {
                // If we detach camera, we can't pan. 
                // Babylon Gizmos handle interaction well enough without detachment.
            });

            scene.onPointerObservable.add((pointerInfo) => {
                const evt = pointerInfo.event;
                if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                    if (evt.button !== 0) return; // ONLY Left Click for selection

                    const pickInfo = pointerInfo.pickInfo;
                    if (pickInfo.hit && pickInfo.pickedMesh && pickInfo.pickedMesh !== ground) {
                        let target = pickInfo.pickedMesh;
                        let p = target.parent;
                        while (p && p !== playerRoot && p.id && p.id.indexOf("recipe_") === -1) {
                            p = p.parent;
                        }
                        if (p && p.id && p.id.indexOf("recipe_") !== -1) target = p;

                        gizmoManager.attachToNode(target);
                    } else {
                        if (!evt.shiftKey) gizmoManager.attachToNode(null);
                    }
                }
            });

            // Global access for UI
            window.MCTwinGizmos = {
                setMode: (m) => {
                    gizmoManager.positionGizmoEnabled = (m === 'move');
                    gizmoManager.rotationGizmoEnabled = (m === 'rotate');
                    gizmoManager.scaleGizmoEnabled = (m === 'scale');
                }
            };

            // ANIMATION & MOVEMENT
            let animTime = 0;
            let isMoving = false;

            scene.registerBeforeRender(function () {
                const dt = engine.getDeltaTime() / 1000.0;
                animTime += dt;

                if (playerRoot) {
                    const speed = 20 * dt;
                    isMoving = false;

                    // Rotation
                    // A/D rotate the body?
                    // Let's do "Tank Controls" for simplicity, or "Camera Relative"
                    // Tank Controls: A/D Rotate, W/S Move
                    // But Camera is ArcRotate...
                    // Let's just do World Space movement for now:
                    // W = -Z (North), S = +Z (South), A = -X (West), D = +X (East)

                    // Actually, let's just do simple Tank Controls relative to character facing.
                    // default facing is North (+Z) or South (-Z)? 
                    // Let's assume Forward is +Z.

                    // WoW-Style Controls
                    // A/D = Rotate
                    const turnSpeed = 3.0 * dt;
                    if (input.a) playerRoot.rotation.y -= turnSpeed;
                    if (input.d) playerRoot.rotation.y += turnSpeed;

                    // W/S = Move Forward/Back
                    const forward = new BABYLON.Vector3(Math.sin(playerRoot.rotation.y), 0, Math.cos(playerRoot.rotation.y));

                    if (input.w) {
                        playerRoot.position.addInPlace(forward.scale(speed));
                        isMoving = true;
                    }
                    if (input.s) {
                        playerRoot.position.subtractInPlace(forward.scale(speed * 0.6));
                        isMoving = true;
                    }

                    // Diagonals override rotation, but position works

                    // Cam Follow
                    if (isMoving) {
                        const desiredTarget = new BABYLON.Vector3(playerRoot.position.x, playerRoot.position.y + 16, playerRoot.position.z);
                        camera.target = BABYLON.Vector3.Lerp(camera.target, desiredTarget, 0.1);
                    }

                    // Animation
                    const legR = meshMap.get("RightLeg");
                    const legL = meshMap.get("LeftLeg");
                    const armR = meshMap.get("RightArm");
                    const armL = meshMap.get("LeftArm");

                    if (isMoving) {
                        const wSpeed = 10;
                        const phase = Math.sin(animTime * wSpeed);
                        if (legR) legR.rotation.x = phase * 0.8;
                        if (legL) legL.rotation.x = -phase * 0.8;
                        if (armR) armR.rotation.x = -phase * 0.8;
                        if (armL) armL.rotation.x = phase * 0.8;
                    } else {
                        // Idle
                        [legR, legL, armR, armL].forEach(m => { if (m) m.rotation.x = 0; });
                        if (armR) armR.rotation.z = 0.05 + Math.sin(animTime) * 0.05;
                        if (armL) armL.rotation.z = -0.05 - Math.sin(animTime) * 0.05;
                    }
                }
            });




            // --- NEXUS BRIDGE INTEGRATION ---
            const parseVec3 = (data, defaultVal = { x: 0, y: 0, z: 0 }) => {
                if (!data) return new BABYLON.Vector3(defaultVal.x, defaultVal.y, defaultVal.z);
                if (Array.isArray(data)) return new BABYLON.Vector3(data[0] ?? defaultVal.x, data[1] ?? defaultVal.y, data[2] ?? defaultVal.z);
                if (typeof data === 'object') return new BABYLON.Vector3(data.x ?? defaultVal.x, data.y ?? defaultVal.y, data.z ?? defaultVal.z);
                return new BABYLON.Vector3(defaultVal.x, defaultVal.y, defaultVal.z);
            };

            const createMaterial = (id, config) => {
                const mat = new BABYLON.PBRMaterial("mat_" + id, scene);
                let color = new BABYLON.Color3(0.5, 0.5, 0.5);
                if (config.ColorHex) color = BABYLON.Color3.FromHexString(config.ColorHex);

                mat.albedoColor = color;
                mat.reflectivityColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                mat.microSurface = 0.9; // Smooth by default

                const type = (config.Material || "Plastic").toLowerCase();

                if (type.includes("metal") || type.includes("chrome")) {
                    mat.metallic = 1.0;
                    mat.roughness = 0.1;
                    mat.reflectivityColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                } else if (type.includes("glass") || type.includes("crystal")) {
                    mat.metallic = 0.2;
                    mat.roughness = 0.05;
                    mat.alpha = 0.4;
                    mat.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHABLEND;
                    // Fresnel-like effect
                    mat.indexOfRefraction = 1.5;
                    mat.directIntensity = 1.2;
                } else if (type.includes("glow") || type.includes("neon")) {
                    mat.emissiveColor = color;
                    mat.emissiveIntensity = 2.0;
                    mat.disableLighting = false; // Allow it to catch shadows/specular
                } else {
                    mat.metallic = 0.0;
                    mat.roughness = 0.5;
                }

                // Use environment reflections if available
                mat.reflectionTexture = scene.environmentTexture;

                return mat;
            };

            window.MCTwin = {
                clear: function () {
                    if (playerRoot) { playerRoot.dispose(); playerRoot = null; }
                    meshMap.clear();
                    // Clear Props too? Maybe keep them? 
                    // Let's keep props if we just reload skin.
                },

                propRegistry: {},
                spawnProp: function (config, parentNode = null) {
                    const id = config.Id || "prop_" + Date.now();

                    let mesh;
                    const shape = (config.Shape || "Box").toLowerCase();
                    const scale = parseVec3(config.Scale, { x: 1, y: 1, z: 1 });

                    try {
                        switch (shape) {
                            case "sphere": mesh = BABYLON.MeshBuilder.CreateSphere("prop_" + id, { diameter: 1, segments: 16 }, scene); break;
                            case "cylinder": mesh = BABYLON.MeshBuilder.CreateCylinder("prop_" + id, { diameter: 1, height: 1, tessellation: 32 }, scene); break;
                            case "plane": mesh = BABYLON.MeshBuilder.CreatePlane("prop_" + id, { size: 1 }, scene); mesh.rotation.x = Math.PI / 2; break;
                            case "torus": mesh = BABYLON.MeshBuilder.CreateTorus("prop_" + id, { diameter: 1, thickness: 0.2, tessellation: 32 }, scene); break;
                            case "capsule": mesh = BABYLON.MeshBuilder.CreateCapsule("prop_" + id, { radius: 0.5, height: 2, tessellation: 32 }, scene); break;
                            default: mesh = BABYLON.MeshBuilder.CreateBox("prop_" + id, { size: 1 }, scene);
                        }
                    } catch (e) { mesh = BABYLON.MeshBuilder.CreateBox("prop_" + id, { size: 1 }, scene); }

                    mesh.scaling = scale;
                    this.propRegistry[id] = mesh;

                    if (config.ParentId && this.propRegistry[config.ParentId]) {
                        mesh.parent = this.propRegistry[config.ParentId];
                    } else if (parentNode) {
                        mesh.parent = parentNode;
                    }

                    const rawPos = parseVec3(config.Position);
                    const rawScale = scale;
                    mesh.intendedScale = rawScale;

                    if (config.ParentId && this.propRegistry[config.ParentId]) {
                        const parentProp = this.propRegistry[config.ParentId];
                        const ps = parentProp.intendedScale || new BABYLON.Vector3(1, 1, 1);
                        // Compensate for immediate parent's non-uniform scaling
                        mesh.scaling = new BABYLON.Vector3(rawScale.x / ps.x, rawScale.y / ps.y, rawScale.z / ps.z);
                        mesh.position = new BABYLON.Vector3(rawPos.x / ps.x, rawPos.y / ps.y, rawPos.z / ps.z);
                    } else {
                        // Root part of the recipe or unparented prop
                        mesh.scaling = rawScale;
                        mesh.position = rawPos;
                    }

                    const rot = parseVec3(config.Rotation);
                    mesh.rotation = new BABYLON.Vector3(BABYLON.Tools.ToRadians(rot.x), BABYLON.Tools.ToRadians(rot.y), BABYLON.Tools.ToRadians(rot.z));

                    mesh.material = createMaterial(id, config);
                    shadowGenerator.addShadowCaster(mesh);
                    mesh.receiveShadows = true;

                    return id;
                },

                spawnRecipe: function (json) {
                    let data = json;
                    if (typeof json === 'string') { try { data = JSON.parse(json); } catch (e) { console.error(e); return; } }

                    const recipeId = data.Id || "recipe_" + Date.now();
                    const container = new BABYLON.TransformNode(recipeId, scene);

                    // Minecraft scaling: 16 units = 1 block.
                    // Nexus 1.0 scale usually means 1 meter. 
                    // Let's use 4.0 multiplier to make a human-sized suit look correct.
                    const globalScaleMultiplier = 4.0;
                    container.scaling = new BABYLON.Vector3(globalScaleMultiplier, globalScaleMultiplier, globalScaleMultiplier);

                    if (playerRoot) {
                        const forward = new BABYLON.Vector3(Math.sin(playerRoot.rotation.y), 0, Math.cos(playerRoot.rotation.y));
                        const spawnPos = playerRoot.position.add(forward.scale(globalScaleMultiplier * 4));
                        spawnPos.y = 0;
                        container.position = spawnPos;
                    }

                    if (data.Parts && Array.isArray(data.Parts)) {
                        console.log("Spawning Recipe: " + data.Name);

                        // 1. Spawn All under container
                        data.Parts.forEach(p => {
                            this.spawnProp(p, container);
                        });

                        // 2. Re-Parent within recipe
                        data.Parts.forEach(p => {
                            if (p.ParentId && this.propRegistry[p.ParentId] && this.propRegistry[p.Id]) {
                                this.propRegistry[p.Id].parent = this.propRegistry[p.ParentId];
                            }
                        });

                        // 3. Auto-Grounding: Find the lowest point and lift the container
                        let minY = Infinity;
                        data.Parts.forEach(p => {
                            const pos = parseVec3(p.Position);
                            const scale = parseVec3(p.Scale, { x: 1, y: 1, z: 1 });
                            // Approximate bottom (assuming center-origin primitives)
                            // Most primitives (Box, Sphere, Cylinder) are 1.0 unit tall at scale 1.0
                            let bottom = pos.y - (0.5 * scale.y);
                            // Capsule is special (height: 2)
                            if ((p.Shape || "").toLowerCase() === "capsule") bottom = pos.y - (1.0 * scale.y);

                            if (bottom < minY) minY = bottom;
                        });

                        if (minY !== Infinity && minY < 0) {
                            // Shift container up by -minY scaled
                            container.position.y += Math.abs(minY) * globalScaleMultiplier;
                        }
                    } else {
                        this.spawnProp(data, container);
                    }
                },

                updateWorld: function (config) {
                    if (config.skyColor) {
                        const c = BABYLON.Color3.FromHexString(config.skyColor);
                        scene.clearColor = new BABYLON.Color4(c.r, c.g, c.b, 1.0);
                    }
                    if (config.groundColor) {
                        groundMat.diffuseColor = BABYLON.Color3.FromHexString(config.groundColor);
                    }
                    if (config.lightIntensity !== undefined) {
                        sun.intensity = config.lightIntensity;
                        hemi.intensity = config.lightIntensity * 0.6;
                    }
                    if (config.groundVisible !== undefined) {
                        ground.setEnabled(config.groundVisible);
                    }
                    if (config.groundSize !== undefined) {
                        const s = config.groundSize / 500.0;
                        ground.scaling = new BABYLON.Vector3(s, 1, s);
                    }
                    if (config.floorTheme) {
                        const themes = {
                            'Checker': { url: "https://assets.babylonjs.com/textures/checkerboard_base.png", scale: 50 },
                            'Concrete': { url: "https://assets.babylonjs.com/textures/concrete.jpg", scale: 20 },
                            'Wood': { url: "https://assets.babylonjs.com/textures/wood.jpg", scale: 10 },
                            'Desert': { url: "https://assets.babylonjs.com/textures/sand.jpg", scale: 20 },
                            'Grass': { url: "https://assets.babylonjs.com/textures/grass.png", scale: 50 },
                            'Space': { url: "https://assets.babylonjs.com/textures/reflectivity.png", scale: 10 }
                        };
                        const theme = themes[config.floorTheme];
                        if (theme) {
                            const tex = new BABYLON.Texture(theme.url, scene);
                            tex.uScale = theme.scale;
                            tex.vScale = theme.scale;
                            groundMat.diffuseTexture = tex;
                            if (config.floorTheme === 'Space') groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                        }
                    }
                },

                runTimeline: function (timeline) {
                    timeline.forEach(event => {
                        const target = this.propRegistry[event.TargetId];
                        if (!target) return;
                        const frameRate = 30;
                        const duration = (event.Duration || 1) * frameRate;
                        if (event.Action === "Move") {
                            // Value is likely in Nexus Units (1m), but our world is 16x.
                            const endPos = parseVec3(event.Value).scale(16);
                            BABYLON.Animation.CreateAndStartAnimation("anim_mv_" + event.TargetId, target, "position", frameRate, duration, target.position, endPos, 0);
                        } else if (event.Action === "Color" && target.material) {
                            const endCol = parseVec3(event.Value); // [r,g,b] 0-1 range
                            BABYLON.Animation.CreateAndStartAnimation("anim_col_" + event.TargetId, target.material, "albedoColor", frameRate, duration, target.material.albedoColor, new BABYLON.Color3(endCol.x, endCol.y, endCol.z), 0);
                            if (target.material.emissiveColor) BABYLON.Animation.CreateAndStartAnimation("anim_emi_" + event.TargetId, target.material, "emissiveColor", frameRate, duration, target.material.emissiveColor, new BABYLON.Color3(endCol.x, endCol.y, endCol.z), 0);
                        }
                    });
                },

                renderModel: function (data) {
                    this.clear();
                    if (!data || !data.Parts) return;

                    playerRoot = new BABYLON.TransformNode("root", scene);

                    // INITIAL POSITION
                    playerRoot.position.y = 12; // Half height of legs/body roughly
                    playerRoot.rotation.y = 0; // Face +Z (Towards Camera at Alpha PI/2)

                    const parts = data.Parts;
                    const skinBase64 = data.Skin;

                    let mat = null;
                    if (skinBase64) {
                        const tex = new BABYLON.Texture(skinBase64, scene, false, true, BABYLON.Texture.NEAREST_SAMPLINGMODE);
                        tex.hasAlpha = true;
                        mat = new BABYLON.StandardMaterial("skinMat", scene);
                        mat.diffuseTexture = tex;
                        mat.specularColor = new BABYLON.Color3(0, 0, 0);
                        mat.backFaceCulling = true;
                        mat.useAlphaFromDiffuseTexture = true;
                    }

                    parts.forEach(p => {
                        // ... UV Logic (Same as viewer.html) ...
                        const w = p.Dimensions[0];
                        const h = p.Dimensions[1];
                        const d = p.Dimensions[2];
                        const tw = (p.TextureDimensions && p.TextureDimensions[0]) ? p.TextureDimensions[0] : w;
                        const th = (p.TextureDimensions && p.TextureDimensions[1]) ? p.TextureDimensions[1] : h;
                        const td = (p.TextureDimensions && p.TextureDimensions[2]) ? p.TextureDimensions[2] : d;
                        const u0 = p.TextureOffset[0];
                        const v0 = p.TextureOffset[1];
                        const pixel = 1.0 / 64.0;
                        const getUV = (xPixel, yPixel, wPixel, hPixel) => {
                            const uMin = xPixel * pixel;
                            const uMax = (xPixel + wPixel) * pixel;
                            const vMax = 1.0 - (yPixel * pixel);
                            const vMin = 1.0 - ((yPixel + hPixel) * pixel);
                            return new BABYLON.Vector4(uMin, vMin, uMax, vMax);
                        };
                        const faceUV = [];
                        faceUV[0] = getUV(u0 + td, v0 + td, tw, th);
                        faceUV[1] = getUV(u0 + td + tw + td, v0 + td, tw, th);
                        faceUV[2] = getUV(u0, v0 + td, td, th);
                        faceUV[3] = getUV(u0 + td + tw, v0 + td, td, th);
                        faceUV[4] = getUV(u0 + td, v0, tw, td);
                        faceUV[5] = getUV(u0 + td + tw, v0, tw, td);

                        const mesh = BABYLON.MeshBuilder.CreateBox(p.Name, {
                            width: w, height: h, depth: d, faceUV: faceUV, wrap: true
                        }, scene);

                        // PARENT TO ROOT
                        mesh.parent = playerRoot;

                        // Local Position relative to Root
                        // p.Offset is Global
                        mesh.position.set(p.Offset[0], p.Offset[1], p.Offset[2]);
                        // Note: -12 is hack strictly for "Standing on ground" if root is at 0?
                        // Actually, let's keep root at 0,0,0 and just set mesh positions as given.
                        // But if HumanoidModel offsets are like 0,24,0...

                        // Let's reset root to 0,0,0
                        // And adjust camera target

                        if (p.Pivot && (p.Pivot[0] !== 0 || p.Pivot[1] !== 0 || p.Pivot[2] !== 0)) {
                            // Pivot is Global in HumanoidModel?
                            // Babylon setPivotPoint is Local.
                            // This is tricky. Let's ignore complex pivot logic here for simplicity and rely on center.
                            // Actually, arms rotate around shoulder.
                            mesh.setPivotPoint(new BABYLON.Vector3(p.Pivot[0], p.Pivot[1], p.Pivot[2]));
                            // Wait, p.Pivot in HumanoidModel was (0, 22, 0) global.
                            // setPivotPoint expects Local relative to mesh center? Or Local Space?
                            // "define the pivot point in the object local space".
                            // If mesh is at (0, 24, 0), pivot at (0,22,0) implies local y = -2.
                            // We need to calculate Local Pivot.

                            const localP = new BABYLON.Vector3(
                                p.Pivot[0] - p.Offset[0],
                                p.Pivot[1] - p.Offset[1],
                                p.Pivot[2] - p.Offset[2]
                            );
                            mesh.setPivotPoint(localP);
                        }

                        if (p.Rotation) {
                            mesh.rotation.x = BABYLON.Tools.ToRadians(p.Rotation[0]);
                            mesh.rotation.y = BABYLON.Tools.ToRadians(p.Rotation[1]);
                            mesh.rotation.z = BABYLON.Tools.ToRadians(p.Rotation[2]);
                        }

                        if (mat) mesh.material = mat;
                        else {
                            const dumbMat = new BABYLON.StandardMaterial("dumb", scene);
                            dumbMat.diffuseColor = p.HexColor ? BABYLON.Color3.FromHexString(p.HexColor) : new BABYLON.Color3(1, 1, 1);
                            mesh.material = dumbMat;
                        }

                        shadowGenerator.addShadowCaster(mesh);
                        meshMap.set(p.Name, mesh);
                    });

                    // Reset Root Position after building children
                    playerRoot.position.y = 0;
                }
            };

            var pipeline = new BABYLON.DefaultRenderingPipeline("pp", true, scene, [camera]);
            pipeline.fxaaEnabled = true;
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.6;
            pipeline.bloomWeight = 0.4;
            pipeline.bloomKernel = 64;
            pipeline.bloomScale = 0.5;

            engine.runRenderLoop(() => scene.render());
            return scene;
        };
        const scene = createScene();
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>

</html>