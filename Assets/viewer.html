<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MCTwin // Industrial Sleek 18.0</title>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #87CEEB;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let shadowGenerator;

        const createScene = function () {
            const scene = new BABYLON.Scene(engine);

            // Minecraft Sky Blue
            scene.clearColor = new BABYLON.Color4(0.53, 0.81, 0.92, 1);
            var env = scene.createDefaultEnvironment({ createSkybox: false, createGround: false, environmentTexture: "https://assets.babylonjs.com/environments/environmentSpecular.env" });
            scene.environmentIntensity = 0.4;

            // Camera (Frontal View) - Set to -Math.PI/2 to look from the FRONT (Negative Z)
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 50, new BABYLON.Vector3(0, 16, 0), scene);
            camera.attachControl(canvas, true);
            camera.wheelPrecision = 10;

            // Lighting
            const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -2, -1), scene);
            sun.position = new BABYLON.Vector3(20, 50, 20);
            sun.intensity = 1.2;

            const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemi.intensity = 0.6; // Lower ambient to make shadows pop
            hemi.groundColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            shadowGenerator = new BABYLON.ShadowGenerator(1024, sun);
            shadowGenerator.useBlurExponentialShadowMap = false;
            shadowGenerator.usePoissonSampling = true;

            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
            const groundMat = new BABYLON.StandardMaterial("gMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.3);
            groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material = groundMat;
            ground.receiveShadows = true;

            const meshMap = new Map();

            window.MCTwin = {
                clear: function () {
                    meshMap.forEach(m => m.dispose());
                    meshMap.clear();
                },

                renderModel: function (data) {
                    this.clear();
                    if (!data || !data.Parts) return;

                    const parts = data.Parts;
                    const skinBase64 = data.Skin;

                    let mat = null;
                    if (skinBase64) {
                        // NOTE: InvertY = true (default) usually flips standard images.
                        // Minecraft skins are drawn Top-Left = 0,0.
                        // Babylon UV space 0,0 is Bottom-Left.
                        // We will correct this in getUV logic.
                        const tex = new BABYLON.Texture(skinBase64, scene, false, true, BABYLON.Texture.NEAREST_SAMPLINGMODE);
                        tex.hasAlpha = true; // IMPORTANT for transparency!

                        mat = new BABYLON.StandardMaterial("skinMat", scene);
                        mat.diffuseTexture = tex;
                        mat.specularColor = new BABYLON.Color3(0, 0, 0);
                        mat.specularColor = new BABYLON.Color3(0, 0, 0);
                        mat.backFaceCulling = true; // Fix "seeing inside" artifacts
                        mat.useAlphaFromDiffuseTexture = true;
                    }

                    parts.forEach(p => {
                        const w = p.Dimensions[0];
                        const h = p.Dimensions[1];
                        const d = p.Dimensions[2];

                        // Use TextureDimensions if provided, otherwise Dimensions
                        const tw = (p.TextureDimensions && p.TextureDimensions[0]) ? p.TextureDimensions[0] : w;
                        const th = (p.TextureDimensions && p.TextureDimensions[1]) ? p.TextureDimensions[1] : h;
                        const td = (p.TextureDimensions && p.TextureDimensions[2]) ? p.TextureDimensions[2] : d;

                        const u0 = p.TextureOffset[0];
                        const v0 = p.TextureOffset[1];
                        const pixel = 1.0 / 64.0;

                        const getUV = (xPixel, yPixel, wPixel, hPixel) => {
                            // Babylon U: 0 (Left) -> 1 (Right)
                            // Babylon V: 0 (Bottom) -> 1 (Top)

                            // Image X: 0 (Left) -> 64 (Right). Matches U.
                            // Image Y: 0 (Top) -> 64 (Bottom). Opposite V.

                            const uMin = xPixel * pixel;
                            const uMax = (xPixel + wPixel) * pixel;

                            const vMax = 1.0 - (yPixel * pixel);            // Top
                            const vMin = 1.0 - ((yPixel + hPixel) * pixel); // Bottom

                            return new BABYLON.Vector4(uMin, vMin, uMax, vMax);
                        };

                        const faceUV = [];
                        // 0 Front: (u0+d, v0+d) -> w, h
                        faceUV[0] = getUV(u0 + td, v0 + td, tw, th);

                        // 1 Back: (u0+d+w+d, v0+d) -> w, h
                        faceUV[1] = getUV(u0 + td + tw + td, v0 + td, tw, th);

                        // 2 Right: (u0, v0+d) -> d, h
                        faceUV[2] = getUV(u0, v0 + td, td, th);

                        // 3 Left: (u0+d+w, v0+d) -> d, h
                        faceUV[3] = getUV(u0 + td + tw, v0 + td, td, th);

                        // 4 Top: (u0+d, v0) -> w, d
                        faceUV[4] = getUV(u0 + td, v0, tw, td);

                        // 5 Bottom: (u0+d+w, v0) -> w, d
                        faceUV[5] = getUV(u0 + td + tw, v0, tw, td);

                        const mesh = BABYLON.MeshBuilder.CreateBox(p.Name, {
                            width: w, height: h, depth: d,
                            faceUV: faceUV,
                            wrap: true
                        }, scene);

                        mesh.position.set(p.Offset[0], p.Offset[1], p.Offset[2]);

                        if (p.Pivot && (p.Pivot[0] !== 0 || p.Pivot[1] !== 0 || p.Pivot[2] !== 0)) {
                            mesh.setPivotPoint(new BABYLON.Vector3(p.Pivot[0], p.Pivot[1], p.Pivot[2]));
                        }

                        if (p.Rotation) {
                            mesh.rotation.x = BABYLON.Tools.ToRadians(p.Rotation[0]);
                            mesh.rotation.y = BABYLON.Tools.ToRadians(p.Rotation[1]);
                            mesh.rotation.z = BABYLON.Tools.ToRadians(p.Rotation[2]);
                        }

                        if (mat) mesh.material = mat;
                        else {
                            const dumbMat = new BABYLON.StandardMaterial("dumb", scene);
                            dumbMat.diffuseColor = p.HexColor ? BABYLON.Color3.FromHexString(p.HexColor) : new BABYLON.Color3(1, 0, 1);
                            mesh.material = dumbMat;
                        }

                        mesh.receiveShadows = true;
                        shadowGenerator.addShadowCaster(mesh);

                        // Edge rendering REMOVED

                        meshMap.set(p.Name, mesh);
                    });
                }
            };

            var pipeline = new BABYLON.DefaultRenderingPipeline("pp", true, scene, [camera]);
            pipeline.samples = 1;
            pipeline.fxaaEnabled = false;

            // ANIMATION SYSTEM
            let animTime = 0;
            let animState = "idle"; // idle, walk, run, wave

            window.MCTwin.setAnimation = function (name) {
                animState = name.toLowerCase();
                animTime = 0; // Reset phase
            };

            scene.registerBeforeRender(function () {
                animTime += engine.getDeltaTime() / 1000.0;

                const head = meshMap.get("Head");
                const hat = meshMap.get("Hat");
                const body = meshMap.get("Body");
                const rArm = meshMap.get("RightArm");
                const lArm = meshMap.get("LeftArm");
                const rLeg = meshMap.get("RightLeg");
                const lLeg = meshMap.get("LeftLeg");
                const rArmLayer = meshMap.get("RightArmLayer"); // If we add layers later
                const lArmLayer = meshMap.get("LeftArmLayer");

                if (animState === "idle") {
                    // Breathing
                    const breath = Math.sin(animTime * 2) * 0.05;
                    if (rArm) rArm.rotation.z = breath + 0.1;
                    if (lArm) lArm.rotation.z = -breath - 0.1;

                    // Reset others
                    if (rLeg) rLeg.rotation.x = 0;
                    if (lLeg) lLeg.rotation.x = 0;
                    if (head) head.rotation.y = Math.sin(animTime * 0.5) * 0.1;
                    if (hat) hat.rotation.y = head ? head.rotation.y : 0;
                }
                else if (animState === "walk") {
                    const speed = 5;
                    const phase = Math.sin(animTime * speed);

                    if (rLeg) rLeg.rotation.x = phase * 0.6;
                    if (lLeg) lLeg.rotation.x = -phase * 0.6;

                    if (rArm) { rArm.rotation.x = -phase * 0.6; rArm.rotation.z = 0.1; }
                    if (lArm) { lArm.rotation.x = phase * 0.6; lArm.rotation.z = -0.1; }

                    // Head bob
                    /* if (head) head.position.y = phase * phase * 0.1 + (existing offset) */
                }
                else if (animState === "run") {
                    const speed = 10;
                    const phase = Math.sin(animTime * speed);

                    if (rLeg) rLeg.rotation.x = phase * 0.8;
                    if (lLeg) lLeg.rotation.x = -phase * 0.8;

                    if (rArm) { rArm.rotation.x = -phase * 0.8; rArm.rotation.z = 0.2; }
                    if (lArm) { lArm.rotation.x = phase * 0.8; lArm.rotation.z = -0.2; }

                    if (body) body.rotation.x = 0.2; // Lean forward
                }
                else if (animState === "wave") {
                    if (rArm) {
                        rArm.rotation.x = Math.PI; // Up
                        rArm.rotation.z = Math.PI - 0.5 + Math.sin(animTime * 10) * 0.5;
                        rArm.rotation.y = 0;
                    }
                    if (lArm) { lArm.rotation.x = 0; lArm.rotation.z = -0.1; }
                    if (rLeg) rLeg.rotation.x = 0;
                    if (lLeg) lLeg.rotation.x = 0;
                }
                else {
                    // Reset All
                    [rArm, lArm, rLeg, lLeg, body, head].forEach(m => { if (m) { m.rotation.x = 0; m.rotation.y = 0; m.rotation.z = 0; } });
                }

                // Sync Hat to Head rotation if animating head
                if (hat && head) {
                    hat.rotation.x = head.rotation.x;
                    hat.rotation.y = head.rotation.y;
                    hat.rotation.z = head.rotation.z;
                }
            });

            engine.runRenderLoop(() => scene.render());
            return scene;
        };
        const scene = createScene();
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>

</html>