<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Face POC - 2D Texture on 3D Head</title>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }

        button {
            padding: 8px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
    </style>
    <!-- Babylon.js CDN -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>
    <canvas id="renderCanvas"></canvas>

    <div id="controls">
        <h3>Face Generator POC</h3>
        <p>Dynamic 2D Canvas mapped to 3D Geometry</p>

        <div class="control-group">
            <label>Skin Tone</label>
            <input type="color" id="skinColor" value="#ffdbac">
        </div>

        <div class="control-group">
            <label>Eye Style</label>
            <select id="eyeStyle">
                <option value="dot">Simple Dots</option>
                <option value="oval">Cartoon Ovals</option>
                <option value="happy">Happy Arcs</option>
                <option value="tired">Tired Lines</option>
            </select>
        </div>

        <div class="control-group">
            <label>Mouth Style</label>
            <select id="mouthStyle">
                <option value="smile">Simple Smile</option>
                <option value="open">Open Mouth (O)</option>
                <option value="frown">Frown</option>
                <option value="smirk">Smirk</option>
                <option value="line">Straight Line</option>
            </select>
        </div>

        <div class="control-group">
            <label>Hair Style</label>
            <select id="hairStyle">
                <option value="none">Bald</option>
                <option value="bob">Bob Cut</option>
                <option value="sidepart">Side Part</option>
                <option value="bangs">Bangs & Bun</option>
            </select>
        </div>

        <div class="control-group">
            <label>Hair Color</label>
            <input type="color" id="hairColor" value="#cc3300">
        </div>

        <div class="control-group">
            <label>Features</label>
            <div>
                <input type="checkbox" id="hasGlasses"> Glasses<br>
                <input type="checkbox" id="hasBlush" checked> Blush<br>
                <input type="checkbox" id="hasBrows" checked> Eyebrows
            </div>
        </div>

        <button onclick="setSecretary()">Preset: Secretary</button>

        <button onclick="randomizeFace()">Randomize</button>
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        let faceTexture;
        let headMaterial;
        let currentConfig = {
            skinColor: "#ffdbac",
            hairColor: "#cc3300",
            hairStyle: "none",
            eyeStyle: "dot",
            mouthStyle: "smile",
            hasGlasses: false,
            hasBlush: true,
            hasBrows: true
        };

        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.9, 0.9, 0.95, 1);

            // Camera
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 4, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            camera.wheelPrecision = 50;
            camera.minZ = 0.1;

            // Lights
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.8;

            const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.position = new BABYLON.Vector3(10, 10, 10);
            dirLight.intensity = 0.5;

            // Material for the Head
            headMaterial = new BABYLON.StandardMaterial("headMat", scene);
            headMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Low gloss, matte skin

            // Dynamic Texture (The Magic Part)
            // 512x512 resolution for crisp lines
            faceTexture = new BABYLON.DynamicTexture("dynamic texture", 1024, scene, true);
            faceTexture.wAng = Math.PI; // Fix Upside Down
            headMaterial.diffuseTexture = faceTexture;

            // Allow transparency if we wanted to overlay this on another texture, 
            // but for now we paint the skin color directly on the canvas.
            faceTexture.hasAlpha = false;

            // Create Head Geometry
            // We use a Sphere with high segments for smoothness, slightly elongated
            const head = BABYLON.MeshBuilder.CreateSphere("head", { diameter: 1.5, segments: 32 }, scene);

            // Rotate the sphere so the texture seam is at the back
            head.rotation.y = Math.PI; // Face the camera

            // Apply Material
            head.material = headMaterial;

            // Draw Initial Face
            updateFace();

            return scene;
        };

        // --- DRAWING LOGIC ---

        function updateFace() {
            if (!faceTexture) return;

            const ctx = faceTexture.getContext();
            const size = faceTexture.getSize().width;
            const w = size;
            const h = size;

            // 1. Fill Skin Background
            ctx.fillStyle = currentConfig.skinColor;
            ctx.fillRect(0, 0, w, h);

            // Helper for symmetry
            const centerX = w / 2;
            const eyeY = h * 0.50; // Moved down slightly to make room for hair
            const mouthY = h * 0.70;
            const eyeOffset = w * 0.10;

            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            // --- HAIR (BACK) ---
            // Drawn before face features so it sits behind
            if (currentConfig.hairStyle !== 'none') {
                ctx.fillStyle = currentConfig.hairColor;
                ctx.beginPath();
                if (currentConfig.hairStyle === 'bob') {
                    // Full coverage on back and sides
                    ctx.arc(centerX, h * 0.5, w * 0.48, 0, Math.PI * 2);
                } else if (currentConfig.hairStyle === 'bangs') {
                    ctx.arc(centerX, h * 0.4, w * 0.48, 0, Math.PI * 2);
                } else if (currentConfig.hairStyle === 'sidepart') {
                    ctx.arc(centerX, h * 0.45, w * 0.46, 0, Math.PI * 2);
                }
                ctx.fill();

                // Redraw Skin mask over face area to "cut out" the face from the hair ball
                ctx.fillStyle = currentConfig.skinColor;
                ctx.beginPath();
                ctx.ellipse(centerX, h * 0.55, w * 0.35, h * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // 2. Draw Blush (Optional)
            if (currentConfig.hasBlush) {
                ctx.fillStyle = "rgba(255, 100, 100, 0.1)";
                ctx.beginPath();
                ctx.arc(centerX - eyeOffset - 20, eyeY + 60, 40, 0, Math.PI * 2);
                ctx.arc(centerX + eyeOffset + 20, eyeY + 60, 40, 0, Math.PI * 2);
                ctx.fill();
            }

            // 3. Draw Eyes
            ctx.fillStyle = "#333"; // Dark gray/black for features
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 15;

            if (currentConfig.eyeStyle === "dot") {
                // Simple Dots
                ctx.beginPath();
                ctx.arc(centerX - eyeOffset, eyeY, 20, 0, Math.PI * 2);
                ctx.arc(centerX + eyeOffset, eyeY, 20, 0, Math.PI * 2);
                ctx.fill();
            } else if (currentConfig.eyeStyle === "oval") {
                // Cartoon Ovals
                ctx.beginPath();
                ctx.ellipse(centerX - eyeOffset, eyeY, 20, 40, 0, 0, Math.PI * 2);
                ctx.ellipse(centerX + eyeOffset, eyeY, 20, 40, 0, 0, Math.PI * 2);
                ctx.fill();
                // Shine
                ctx.fillStyle = "#FFF";
                ctx.beginPath();
                ctx.arc(centerX - eyeOffset + 5, eyeY - 10, 8, 0, Math.PI * 2);
                ctx.arc(centerX + eyeOffset + 5, eyeY - 10, 8, 0, Math.PI * 2);
                ctx.fill();
            } else if (currentConfig.eyeStyle === "happy") {
                // Happy Arcs ^ ^
                ctx.beginPath();
                ctx.arc(centerX - eyeOffset, eyeY, 30, Math.PI + 0.5, -0.5); // Left
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX + eyeOffset, eyeY, 30, Math.PI + 0.5, -0.5); // Right
                ctx.stroke();
            } else if (currentConfig.eyeStyle === "tired") {
                // Flat lines - -
                ctx.beginPath();
                ctx.moveTo(centerX - eyeOffset - 25, eyeY);
                ctx.lineTo(centerX - eyeOffset + 25, eyeY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX + eyeOffset - 25, eyeY);
                ctx.lineTo(centerX + eyeOffset + 25, eyeY);
                ctx.stroke();
            }

            // 4. Draw Brows
            if (currentConfig.hasBrows) {
                ctx.strokeStyle = currentConfig.hairStyle !== 'none' ? currentConfig.hairColor : "#5b4034";
                if (currentConfig.hairStyle === 'none') ctx.strokeStyle = "#333"; // Default for bald

                ctx.lineWidth = 12;
                const browY = eyeY - 50;
                ctx.beginPath();
                // Simple curved brows
                ctx.moveTo(centerX - eyeOffset - 30, browY);
                ctx.quadraticCurveTo(centerX - eyeOffset, browY - 20, centerX - eyeOffset + 30, browY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX + eyeOffset - 30, browY);
                ctx.quadraticCurveTo(centerX + eyeOffset, browY - 20, centerX + eyeOffset + 30, browY);
                ctx.stroke();
            }

            // 5. Draw Glasses (Optional)
            if (currentConfig.hasGlasses) {
                ctx.strokeStyle = "#333"; // Black frames
                ctx.lineWidth = 8;
                ctx.fillStyle = "rgba(200, 230, 255, 0.3)"; // Glass tint

                // Left Lens
                ctx.beginPath();
                ctx.arc(centerX - eyeOffset, eyeY, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Right Lens
                ctx.beginPath();
                ctx.arc(centerX + eyeOffset, eyeY, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Bridge
                ctx.beginPath();
                ctx.moveTo(centerX - eyeOffset + 50, eyeY);
                ctx.lineTo(centerX + eyeOffset - 50, eyeY);
                ctx.stroke();
            }

            // 6. Draw Mouth
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 15;
            ctx.fillStyle = "#600"; // Dark red for open mouth

            if (currentConfig.mouthStyle === "smile") {
                ctx.beginPath();
                ctx.arc(centerX, mouthY - 20, 60, 0.2, Math.PI - 0.2);
                ctx.stroke();
            } else if (currentConfig.mouthStyle === "frown") {
                ctx.beginPath();
                ctx.arc(centerX, mouthY + 40, 50, Math.PI + 0.2, -0.2);
                ctx.stroke();
            } else if (currentConfig.mouthStyle === "open") {
                ctx.beginPath();
                ctx.ellipse(centerX, mouthY + 10, 30, 40, 0, 0, Math.PI * 2);
                ctx.fill(); // Fill with dark red
            } else if (currentConfig.mouthStyle === "smirk") {
                ctx.beginPath();
                ctx.moveTo(centerX - 40, mouthY);
                ctx.quadraticCurveTo(centerX, mouthY + 10, centerX + 40, mouthY - 20);
                ctx.stroke();
            } else if (currentConfig.mouthStyle === "line") {
                ctx.beginPath();
                ctx.moveTo(centerX - 40, mouthY);
                ctx.lineTo(centerX + 40, mouthY);
                ctx.stroke();
            }

            // --- HAIR (FRONT / BANGS) ---
            if (currentConfig.hairStyle !== 'none') {
                ctx.fillStyle = currentConfig.hairColor;
                ctx.beginPath();

                if (currentConfig.hairStyle === 'sidepart') {
                    // Swoop across forehead
                    ctx.moveTo(0, h * 0.3);
                    ctx.quadraticCurveTo(centerX, h * 0.5, w, h * 0.2);
                    ctx.lineTo(w, 0);
                    ctx.lineTo(0, 0);
                    ctx.fill();
                } else if (currentConfig.hairStyle === 'bangs') {
                    // Styled Bangs (Not a bowl cut)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, h * 0.45); // Sideburn length
                    // Swoop up for the face visibility
                    ctx.quadraticCurveTo(w * 0.1, h * 0.45, w * 0.2, h * 0.35);
                    // Main bang curve across forehead
                    ctx.quadraticCurveTo(centerX, h * 0.42, w * 0.8, h * 0.35);
                    // Swoop down right side
                    ctx.quadraticCurveTo(w * 0.9, h * 0.45, w, h * 0.45);
                    ctx.lineTo(w, 0);
                    ctx.fill();

                } else if (currentConfig.hairStyle === 'bob') {
                    // Bob framing
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(w, 0);
                    ctx.lineTo(w, h * 0.3);
                    ctx.quadraticCurveTo(centerX, h * 0.4, 0, h * 0.3);
                    ctx.fill();
                }
            }

            // Send update to GPU
            faceTexture.update();
        }

        // --- UI BINDINGS ---
        document.getElementById("skinColor").addEventListener("input", (e) => {
            currentConfig.skinColor = e.target.value;
            updateFace();
        });
        document.getElementById("hairColor").addEventListener("input", (e) => {
            currentConfig.hairColor = e.target.value;
            updateFace();
        });

        document.getElementById("eyeStyle").addEventListener("change", (e) => {
            currentConfig.eyeStyle = e.target.value;
            updateFace();
        });
        document.getElementById("hairStyle").addEventListener("change", (e) => {
            currentConfig.hairStyle = e.target.value;
            updateFace();
        });

        document.getElementById("mouthStyle").addEventListener("change", (e) => {
            currentConfig.mouthStyle = e.target.value;
            updateFace();
        });

        document.getElementById("hasGlasses").addEventListener("change", (e) => {
            currentConfig.hasGlasses = e.target.checked;
            updateFace();
        });

        document.getElementById("hasBlush").addEventListener("change", (e) => {
            currentConfig.hasBlush = e.target.checked;
            updateFace();
        });

        document.getElementById("hasBrows").addEventListener("change", (e) => {
            currentConfig.hasBrows = e.target.checked;
            updateFace();
        });

        function setSecretary() {
            currentConfig.hairStyle = "bangs";
            currentConfig.hairColor = "#cc3300"; // Red
            currentConfig.skinColor = "#ffdbac";
            currentConfig.hasGlasses = true;
            currentConfig.eyeStyle = "oval";
            currentConfig.mouthStyle = "smirk";

            updateUI();
            updateFace();
        }

        function updateUI() {
            document.getElementById("eyeStyle").value = currentConfig.eyeStyle;
            document.getElementById("mouthStyle").value = currentConfig.mouthStyle;
            document.getElementById("hairStyle").value = currentConfig.hairStyle;
            document.getElementById("hasGlasses").checked = currentConfig.hasGlasses;
            document.getElementById("skinColor").value = currentConfig.skinColor;
            document.getElementById("hairColor").value = currentConfig.hairColor;
        }

        function randomizeFace() {
            const eyes = ["dot", "oval", "happy", "tired"];
            const mouths = ["smile", "open", "frown", "smirk", "line"];
            const hairs = ["none", "bob", "sidepart", "bangs"];

            currentConfig.eyeStyle = eyes[Math.floor(Math.random() * eyes.length)];
            currentConfig.mouthStyle = mouths[Math.floor(Math.random() * mouths.length)];
            currentConfig.hairStyle = hairs[Math.floor(Math.random() * hairs.length)];
            currentConfig.hasGlasses = Math.random() > 0.7;
            currentConfig.hasBrows = true; // Most keep brows

            // Random skin tone
            const skins = ["#ffdbac", "#f1c27d", "#e0ac69", "#8d5524", "#c68642"];
            currentConfig.skinColor = skins[Math.floor(Math.random() * skins.length)];

            // Random hair color
            const hairColors = ["#000000", "#cc3300", "#ebd834", "#5b4034"];
            currentConfig.hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];

            updateUI();
            updateFace();
        }

        const scene = createScene();
        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());

    </script>
</body>

</html>